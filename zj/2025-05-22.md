以下是按照给定的树形结构和图网络结构知识点生成的 10 篇 C++ 信息竞赛学生的知识点总结：

### 总结 1：树形结构 01 - 树的概念，存储及遍历
#### 树的概念
树是一种无向无环的连通图，由节点和边组成。有一个特殊的节点称为根节点，除根节点外，每个节点都有一个父节点。树的节点可以有零个或多个子节点。

#### 存储方式
- **邻接表**：使用 `vector<int> adj[N]` 来存储树的边，其中 `adj[i]` 存储节点 `i` 的所有子节点。
```cpp
#include <vector>
const int N = 100005;
vector<int> adj[N];

// 添加边
void addEdge(int u, int v) {
    adj[u].push_back(v);
    adj[v].push_back(u);
}
```
- **链式前向星**：通过数组模拟链表来存储边。

#### 遍历方式
- **深度优先搜索（DFS）**：递归地访问每个节点及其子节点。
```cpp
void dfs(int u, int parent) {
    // 处理当前节点
    for (int v : adj[u]) {
        if (v != parent) {
            dfs(v, u);
        }
    }
}
```
- **广度优先搜索（BFS）**：使用队列按层遍历树。
```cpp
#include <queue>
void bfs(int root) {
    queue<int> q;
    q.push(root);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        // 处理当前节点
        for (int v : adj[u]) {
            q.push(v);
        }
    }
}
```

### 总结 2：树形结构 02 - 树的直径及其性质
#### 树的直径定义
树中任意两个节点之间的最长路径称为树的直径。

#### 求树的直径的方法
- **两次 DFS 法**：
    1. 从任意节点 `u` 开始进行 DFS，找到距离 `u` 最远的节点 `v`。
    2. 从节点 `v` 开始进行 DFS，找到距离 `v` 最远的节点 `w`。节点 `v` 到节点 `w` 的路径即为树的直径。
```cpp
int maxDist, farthestNode;
void dfs(int u, int parent, int dist) {
    if (dist > maxDist) {
        maxDist = dist;
        farthestNode = u;
    }
    for (int v : adj[u]) {
        if (v != parent) {
            dfs(v, u, dist + 1);
        }
    }
}

int getDiameter() {
    maxDist = -1;
    dfs(1, -1, 0);
    int start = farthestNode;
    maxDist = -1;
    dfs(start, -1, 0);
    return maxDist;
}
```

#### 性质
- 树的直径可能不唯一，但所有直径都有公共部分。
- 树的中心位于树的直径上。

### 总结 3：树形结构 03 - 树的重心及其性质
#### 树的重心定义
树的重心是指树中的一个节点，删除该节点后，剩余的各个连通分量中节点数的最大值最小。

#### 求树的重心的方法
通过 DFS 遍历树，计算每个节点删除后各个连通分量的节点数。
```cpp
int n;
int sz[N], centroid;
void dfs(int u, int parent) {
    sz[u] = 1;
    int maxSubtree = 0;
    for (int v : adj[u]) {
        if (v != parent) {
            dfs(v, u);
            sz[u] += sz[v];
            maxSubtree = max(maxSubtree, sz[v]);
        }
    }
    maxSubtree = max(maxSubtree, n - sz[u]);
    if (maxSubtree < n / 2) {
        centroid = u;
    }
}
```

#### 性质
- 树的重心最多有两个。
- 树的重心到所有节点的距离之和最小。

### 总结 4：树形结构 04 - 树的集合性质与并查集
#### 并查集的概念
并查集是一种用于处理不相交集合的合并与查询问题的数据结构，支持两种操作：
- **合并（Union）**：将两个集合合并为一个集合。
- **查询（Find）**：查询两个元素是否属于同一个集合。

#### 实现代码
```cpp
int parent[N];
void init() {
    for (int i = 1; i <= n; i++) {
        parent[i] = i;
    }
}

int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);
    }
    return parent[x];
}

void unite(int x, int y) {
    int px = find(x);
    int py = find(y);
    if (px != py) {
        parent[px] = py;
    }
}
```

#### 在树中的应用
可以使用并查集来判断树的连通性，以及处理树的合并问题。

### 总结 5：树形结构 05 - 二叉树的存储遍历和转化
#### 二叉树的存储
- **数组存储**：使用数组 `tree[N]` 来存储二叉树，`tree[i]` 表示节点 `i` 的值，`tree[2 * i]` 和 `tree[2 * i + 1]` 分别表示节点 `i` 的左子节点和右子节点。
- **指针存储**：使用结构体和指针来存储二叉树。
```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

#### 遍历方式
- **前序遍历**：根节点 -> 左子树 -> 右子树
```cpp
void preOrder(TreeNode* root) {
    if (root) {
        cout << root->val << " ";
        preOrder(root->left);
        preOrder(root->right);
    }
}
```
- **中序遍历**：左子树 -> 根节点 -> 右子树
- **后序遍历**：左子树 -> 右子树 -> 根节点

#### 转化
可以将二叉树转化为线索二叉树、哈夫曼树等。

### 总结 6：图网络结构 01 - 图的概念及储存遍历
#### 图的概念
图是由节点和边组成的一种数据结构，分为有向图和无向图。

#### 存储方式
- **邻接矩阵**：使用二维数组 `graph[N][N]` 来存储图的边，`graph[i][j]` 表示节点 `i` 到节点 `j` 的边的权重。
- **邻接表**：同树的邻接表存储方式。

#### 遍历方式
- **深度优先搜索（DFS）**：
```cpp
void dfs(int u) {
    visited[u] = true;
    // 处理当前节点
    for (int v : adj[u]) {
        if (!visited[v]) {
            dfs(v);
        }
    }
}
```
- **广度优先搜索（BFS）**：
```cpp
void bfs(int s) {
    queue<int> q;
    q.push(s);
    visited[s] = true;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        // 处理当前节点
        for (int v : adj[u]) {
            if (!visited[v]) {
                q.push(v);
                visited[v] = true;
            }
        }
    }
}
```

### 总结 7：图网络结构 02 - 单源最短路问题
#### 问题描述
给定一个图和一个源节点，求源节点到图中所有其他节点的最短路径。

#### 算法
- **Dijkstra 算法**：适用于边权非负的图。
```cpp
#include <queue>
typedef pair<int, int> pii;
const int INF = 1e9;
int dist[N];
void dijkstra(int s) {
    fill(dist, dist + N, INF);
    dist[s] = 0;
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    pq.push({0, s});
    while (!pq.empty()) {
        int u = pq.top().second;
        int d = pq.top().first;
        pq.pop();
        if (d > dist[u]) continue;
        for (pii edge : adj[u]) {
            int v = edge.first;
            int w = edge.second;
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
}
```
- **Bellman - Ford 算法**：适用于存在负权边的图，但不能处理负环。

### 总结 8：图网络结构 03 - 多源最短路与负环判定
#### 多源最短路问题
求图中任意两个节点之间的最短路径。

#### 算法
- **Floyd - Warshall 算法**：
```cpp
const int INF = 1e9;
int dist[N][N];
void floydWarshall() {
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
}
```

#### 负环判定
使用 Bellman - Ford 算法或 Floyd - Warshall 算法可以判断图中是否存在负环。

### 总结 9：图网络结构 04 - DAG 与拓扑排序
#### DAG 定义
有向无环图（DAG）是一种有向图，其中不存在环。

#### 拓扑排序定义
对 DAG 的节点进行排序，使得对于任意一条有向边 `(u, v)`，节点 `u` 在排序中都出现在节点 `v` 之前。

#### 算法
- **Kahn 算法**：
```cpp
vector<int> topoSort() {
    vector<int> inDegree(n + 1, 0);
    for (int u = 1; u <= n; u++) {
        for (int v : adj[u]) {
            inDegree[v]++;
        }
    }
    queue<int> q;
    for (int i = 1; i <= n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }
    vector<int> result;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        result.push_back(u);
        for (int v : adj[u]) {
            inDegree[v]--;
            if (inDegree[v] == 0) {
                q.push(v);
            }
        }
    }
    return result;
}
```

### 总结 10：图网络结构 05 - 最小生成树
#### 问题描述
给定一个带权无向图，求一个边的子集，使得这些边连接所有节点，且边的权值之和最小。

#### 算法
- **Prim 算法**：
```cpp
typedef pair<int, int> pii;
const int INF = 1e9;
int dist[N];
bool visited[N];
int prim() {
    fill(dist, dist + N, INF);
    fill(visited, visited + N, false);
    dist[1] = 0;
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    pq.push({0, 1});
    int mstWeight = 0;
    while (!pq.empty()) {
        int u = pq.top().second;
        int d = pq.top().first;
        pq.pop();
        if (visited[u]) continue;
        visited[u] = true;
        mstWeight += d;
        for (pii edge : adj[u]) {
            int v = edge.first;
            int w = edge.second;
            if (!visited[v] && w < dist[v]) {
                dist[v] = w;
                pq.push({dist[v], v});
            }
        }
    }
    return mstWeight;
}
```
- **Kruskal 算法**：使用并查集来实现。