#zsd
知识点 由 李明天 提供支持，因此可能会存在错误。请在食用前仔细查看知识点内容。
### 动态规划基础概念
动态规划（Dynamic Programming，简称 DP）是一种用于解决优化问题的算法策略。它通过将原问题分解为相对简单的子问题，并保存子问题的解来避免重复计算，从而提高算法的效率。

#### 适用条件
- **最优子结构**：问题的最优解可以由其子问题的最优解组合而成。也就是说，一个大问题的最优解包含了小问题的最优解。
- **子问题重叠**：在求解过程中，会多次遇到相同的子问题。动态规划通过记录这些子问题的解，避免了重复计算。

#### 基本步骤
1. **定义状态**：明确问题的状态表示，即如何用一个或多个变量来描述问题的子问题。状态的定义要能够准确地刻画问题的特征。
2. **确定状态转移方程**：根据问题的最优子结构性质，找出状态之间的递推关系。状态转移方程描述了如何从已知的子问题的解推导出当前问题的解。
3. **初始化边界条件**：确定状态转移方程的初始状态，即最小子问题的解。边界条件是递推的起点，没有边界条件，状态转移方程无法进行递推。
4. **计算顺序**：根据状态转移方程的依赖关系，确定计算状态的顺序。通常是从边界状态开始，逐步计算出所有需要的状态。

### 常见动态规划类型

#### 线性动态规划
线性动态规划是指状态的定义和状态转移方程具有线性的特征，通常可以用一维数组或二维数组来表示状态。

**示例：最长上升子序列（LIS）**
问题描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。
状态定义：设 `dp[i]` 表示以第 `i` 个元素结尾的最长上升子序列的长度。
状态转移方程：`dp[i] = max(dp[j]) + 1`，其中 `0 <= j < i` 且 `nums[j] < nums[i]`。
边界条件：`dp[i] = 1`，因为每个元素自身可以构成一个长度为 1 的上升子序列。
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    vector<int> dp(n, 1);
    int ans = 1;
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[j] < nums[i]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
        ans = max(ans, dp[i]);
    }
    return ans;
}

int main() {
    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};
    cout << "最长上升子序列的长度为: " << lengthOfLIS(nums) << endl;
    return 0;
}
```

#### 区间动态规划
区间动态规划是指状态的定义和状态转移方程与区间有关，通常用二维数组 `dp[i][j]` 表示区间 `[i, j]` 上的最优解。

**示例：石子合并问题**
问题描述：有 `n` 堆石子排成一排，每堆石子有一定的数量。每次可以将相邻的两堆石子合并成一堆，合并的代价是这两堆石子的数量之和。求将所有石子合并成一堆的最小代价。
状态定义：设 `dp[i][j]` 表示将区间 `[i, j]` 内的石子合并成一堆的最小代价。
状态转移方程：`dp[i][j] = min(dp[i][k] + dp[k + 1][j]) + sum[i][j]`，其中 `i <= k < j`，`sum[i][j]` 表示区间 `[i, j]` 内石子的数量之和。
边界条件：`dp[i][i] = 0`，因为只有一堆石子不需要合并。
```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int stoneMerge(vector<int>& stones) {
    int n = stones.size();
    vector<int> sum(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        sum[i] = sum[i - 1] + stones[i - 1];
    }
    vector<vector<int>> dp(n, vector<int>(n, 0));
    for (int len = 2; len <= n; ++len) {
        for (int i = 0; i <= n - len; ++i) {
            int j = i + len - 1;
            dp[i][j] = INT_MAX;
            for (int k = i; k < j; ++k) {
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[j + 1] - sum[i]);
            }
        }
    }
    return dp[0][n - 1];
}

int main() {
    vector<int> stones = {3, 2, 4, 1};
    cout << "最小合并代价为: " << stoneMerge(stones) << endl;
    return 0;
}
```

#### 背包动态规划
背包问题是一类经典的动态规划问题，常见的有 0 - 1 背包问题、完全背包问题、多重背包问题等。

**0 - 1 背包问题**
问题描述：有 `n` 个物品和一个容量为 `W` 的背包，每个物品有一个重量 `w[i]` 和一个价值 `v[i]`，要求选择一些物品放入背包中，使得背包中物品的总价值最大，且每个物品只能选择一次。
状态定义：设 `dp[i][j]` 表示前 `i` 个物品放入容量为 `j` 的背包中所能获得的最大价值。
状态转移方程：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])`，其中 `j >= w[i]`。
边界条件：`dp[0][j] = 0`，`dp[i][0] = 0`。
```cpp
#include <iostream>
#include <vector>

using namespace std;

int knapsack(int W, vector<int>& w, vector<int>& v) {
    int n = w.size();
    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= W; ++j) {
            if (j < w[i - 1]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]);
            }
        }
    }
    return dp[n][W];
}

int main() {
    int W = 5;
    vector<int> w = {2, 1, 3};
    vector<int> v = {3, 2, 4};
    cout << "最大价值为: " << knapsack(W, w, v) << endl;
    return 0;
}
```

### 动态规划优化技巧
- **滚动数组**：当状态转移方程只依赖于前一个或前几个状态时，可以使用滚动数组来减少空间复杂度。例如，在 0 - 1 背包问题中，可以将二维数组 `dp[i][j]` 优化为一维数组 `dp[j]`。
- **状态压缩**：通过对状态进行合理的编码，减少状态的维度，从而降低空间复杂度。例如，在某些问题中，可以使用位运算来表示状态。

### 动态规划常见错误及解决方法
- **状态定义错误**：状态定义不准确会导致状态转移方程无法正确推导。解决方法是仔细分析问题的特征，明确问题的子问题，确保状态能够准确描述问题。
- **边界条件错误**：边界条件设置错误会导致递推无法正确进行。解决方法是仔细分析最小子问题的解，确保边界条件的正确性。
- **状态转移方程错误**：状态转移方程推导错误会导致最终结果错误。解决方法是通过手动模拟一些简单的情况，验证状态转移方程的正确性。

### 总结
动态规划是一种强大的算法策略，在信息竞赛中经常出现。掌握动态规划的基本概念、常见类型和优化技巧，能够帮助你解决各种复杂的优化问题。在实际应用中，需要通过大量的练习来提高对动态规划的理解和运用能力。