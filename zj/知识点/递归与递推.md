#zsd 
### 递归与递推概述
在信息竞赛里，递归与递推属于重要的算法思想，二者都能够解决具备重复子问题特性的问题，不过它们的实现方式和应用场景存在差异。

### 递归
#### 概念
递归指的是在函数的定义里使用函数自身的方法。一个递归函数通常包含两部分：
- **递归边界**：也就是递归结束的条件，防止函数无限调用。
- **递归关系**：把大问题分解成规模更小的子问题。

#### 示例代码
以下是计算阶乘的递归代码：
```cpp
#include <iostream>
using namespace std;

// 递归函数计算阶乘
int factorial(int n) {
    // 递归边界
    if (n == 0 || n == 1) {
        return 1;
    }
    // 递归关系
    return n * factorial(n - 1);
}

int main() {
    int n = 5;
    cout << "Factorial of " << n << " is " << factorial(n) << endl;
    return 0;
}
```
#### 复杂度分析
- **时间复杂度**：通常和递归的深度有关，对于阶乘函数，时间复杂度是$O(n)$。
- **空间复杂度**：主要取决于递归栈的深度，阶乘函数的空间复杂度同样是$O(n)$。

#### 应用场景
- **树和图的遍历**：像深度优先搜索（DFS）。
- **分治算法**：例如归并排序、快速排序。

### 递推
#### 概念
递推是通过已知的初始条件，逐步推导得出后续的结果。递推一般分为顺推和逆推。
- **顺推**：从初始状态开始，按照一定的规律逐步推出后续状态。
- **逆推**：从最终状态出发，逆向推导出初始状态。

#### 示例代码
以下是计算斐波那契数列的递推代码：
```cpp
#include <iostream>
using namespace std;

// 递推函数计算斐波那契数列
int fibonacci(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    int a = 0, b = 1, c;
    for (int i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}

int main() {
    int n = 6;
    cout << "Fibonacci number at position " << n << " is " << fibonacci(n) << endl;
    return 0;
}
```
#### 复杂度分析
- **时间复杂度**：一般是$O(n)$，因为只需要遍历一次。
- **空间复杂度**：通常是$O(1)$，只需要常数级的额外空间。

#### 应用场景
- **动态规划**：很多动态规划问题都能够通过递推来解决。
- **数列问题**：如斐波那契数列、卡特兰数等。

### 递归与递推的比较
- **代码实现**：递归代码通常更简洁，易于理解；递推代码则更注重状态的转移，代码相对复杂一些。
- **效率**：递归可能会因为重复计算导致效率低下，而递推可以避免这一问题，因此在时间和空间复杂度上通常更优。
- **栈溢出风险**：递归由于使用系统栈，当递归深度过大时，可能会导致栈溢出；递推则不存在这个问题。

### 注意事项
- **递归深度**：在使用递归时，要注意递归深度，避免栈溢出。
- **重复计算**：递归可能会有大量的重复计算，可使用记忆化搜索来优化。
- **边界条件**：无论是递归还是递推，都要准确确定边界条件，否则可能会得到错误的结果。

### 总结
递归和递推是解决重复子问题的两种重要方法，各有优缺点。在信息竞赛中，需要根据具体问题的特点，选择合适的方法来解决问题。同时，要注意代码的效率和边界条件的处理。 